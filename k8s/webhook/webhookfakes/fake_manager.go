// Code generated by counterfeiter. DO NOT EDIT.
package webhookfakes

import (
	"sync"

	extension "code.cloudfoundry.org/eirinix"
	"go.uber.org/zap"
	v1a "k8s.io/api/core/v1"
	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

type FakeManager struct {
	AddExtensionStub        func(extension.Extension)
	addExtensionMutex       sync.RWMutex
	addExtensionArgsForCall []struct {
		arg1 extension.Extension
	}
	AddWatcherStub        func(extension.Watcher)
	addWatcherMutex       sync.RWMutex
	addWatcherArgsForCall []struct {
		arg1 extension.Watcher
	}
	GetKubeClientStub        func() (v1.CoreV1Interface, error)
	getKubeClientMutex       sync.RWMutex
	getKubeClientArgsForCall []struct {
	}
	getKubeClientReturns struct {
		result1 v1.CoreV1Interface
		result2 error
	}
	getKubeClientReturnsOnCall map[int]struct {
		result1 v1.CoreV1Interface
		result2 error
	}
	GetKubeConnectionStub        func() (*rest.Config, error)
	getKubeConnectionMutex       sync.RWMutex
	getKubeConnectionArgsForCall []struct {
	}
	getKubeConnectionReturns struct {
		result1 *rest.Config
		result2 error
	}
	getKubeConnectionReturnsOnCall map[int]struct {
		result1 *rest.Config
		result2 error
	}
	GetLoggerStub        func() *zap.SugaredLogger
	getLoggerMutex       sync.RWMutex
	getLoggerArgsForCall []struct {
	}
	getLoggerReturns struct {
		result1 *zap.SugaredLogger
	}
	getLoggerReturnsOnCall map[int]struct {
		result1 *zap.SugaredLogger
	}
	GetManagerOptionsStub        func() extension.ManagerOptions
	getManagerOptionsMutex       sync.RWMutex
	getManagerOptionsArgsForCall []struct {
	}
	getManagerOptionsReturns struct {
		result1 extension.ManagerOptions
	}
	getManagerOptionsReturnsOnCall map[int]struct {
		result1 extension.ManagerOptions
	}
	ListExtensionsStub        func() []extension.Extension
	listExtensionsMutex       sync.RWMutex
	listExtensionsArgsForCall []struct {
	}
	listExtensionsReturns struct {
		result1 []extension.Extension
	}
	listExtensionsReturnsOnCall map[int]struct {
		result1 []extension.Extension
	}
	PatchFromPodStub        func(admission.Request, *v1a.Pod) admission.Response
	patchFromPodMutex       sync.RWMutex
	patchFromPodArgsForCall []struct {
		arg1 admission.Request
		arg2 *v1a.Pod
	}
	patchFromPodReturns struct {
		result1 admission.Response
	}
	patchFromPodReturnsOnCall map[int]struct {
		result1 admission.Response
	}
	RegisterExtensionsStub        func() error
	registerExtensionsMutex       sync.RWMutex
	registerExtensionsArgsForCall []struct {
	}
	registerExtensionsReturns struct {
		result1 error
	}
	registerExtensionsReturnsOnCall map[int]struct {
		result1 error
	}
	SetManagerOptionsStub        func(extension.ManagerOptions)
	setManagerOptionsMutex       sync.RWMutex
	setManagerOptionsArgsForCall []struct {
		arg1 extension.ManagerOptions
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func()
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
	}
	WatchStub        func() error
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
	}
	watchReturns struct {
		result1 error
	}
	watchReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) AddExtension(arg1 extension.Extension) {
	fake.addExtensionMutex.Lock()
	fake.addExtensionArgsForCall = append(fake.addExtensionArgsForCall, struct {
		arg1 extension.Extension
	}{arg1})
	fake.recordInvocation("AddExtension", []interface{}{arg1})
	fake.addExtensionMutex.Unlock()
	if fake.AddExtensionStub != nil {
		fake.AddExtensionStub(arg1)
	}
}

func (fake *FakeManager) AddExtensionCallCount() int {
	fake.addExtensionMutex.RLock()
	defer fake.addExtensionMutex.RUnlock()
	return len(fake.addExtensionArgsForCall)
}

func (fake *FakeManager) AddExtensionCalls(stub func(extension.Extension)) {
	fake.addExtensionMutex.Lock()
	defer fake.addExtensionMutex.Unlock()
	fake.AddExtensionStub = stub
}

func (fake *FakeManager) AddExtensionArgsForCall(i int) extension.Extension {
	fake.addExtensionMutex.RLock()
	defer fake.addExtensionMutex.RUnlock()
	argsForCall := fake.addExtensionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) AddWatcher(arg1 extension.Watcher) {
	fake.addWatcherMutex.Lock()
	fake.addWatcherArgsForCall = append(fake.addWatcherArgsForCall, struct {
		arg1 extension.Watcher
	}{arg1})
	fake.recordInvocation("AddWatcher", []interface{}{arg1})
	fake.addWatcherMutex.Unlock()
	if fake.AddWatcherStub != nil {
		fake.AddWatcherStub(arg1)
	}
}

func (fake *FakeManager) AddWatcherCallCount() int {
	fake.addWatcherMutex.RLock()
	defer fake.addWatcherMutex.RUnlock()
	return len(fake.addWatcherArgsForCall)
}

func (fake *FakeManager) AddWatcherCalls(stub func(extension.Watcher)) {
	fake.addWatcherMutex.Lock()
	defer fake.addWatcherMutex.Unlock()
	fake.AddWatcherStub = stub
}

func (fake *FakeManager) AddWatcherArgsForCall(i int) extension.Watcher {
	fake.addWatcherMutex.RLock()
	defer fake.addWatcherMutex.RUnlock()
	argsForCall := fake.addWatcherArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) GetKubeClient() (v1.CoreV1Interface, error) {
	fake.getKubeClientMutex.Lock()
	ret, specificReturn := fake.getKubeClientReturnsOnCall[len(fake.getKubeClientArgsForCall)]
	fake.getKubeClientArgsForCall = append(fake.getKubeClientArgsForCall, struct {
	}{})
	fake.recordInvocation("GetKubeClient", []interface{}{})
	fake.getKubeClientMutex.Unlock()
	if fake.GetKubeClientStub != nil {
		return fake.GetKubeClientStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getKubeClientReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetKubeClientCallCount() int {
	fake.getKubeClientMutex.RLock()
	defer fake.getKubeClientMutex.RUnlock()
	return len(fake.getKubeClientArgsForCall)
}

func (fake *FakeManager) GetKubeClientCalls(stub func() (v1.CoreV1Interface, error)) {
	fake.getKubeClientMutex.Lock()
	defer fake.getKubeClientMutex.Unlock()
	fake.GetKubeClientStub = stub
}

func (fake *FakeManager) GetKubeClientReturns(result1 v1.CoreV1Interface, result2 error) {
	fake.getKubeClientMutex.Lock()
	defer fake.getKubeClientMutex.Unlock()
	fake.GetKubeClientStub = nil
	fake.getKubeClientReturns = struct {
		result1 v1.CoreV1Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetKubeClientReturnsOnCall(i int, result1 v1.CoreV1Interface, result2 error) {
	fake.getKubeClientMutex.Lock()
	defer fake.getKubeClientMutex.Unlock()
	fake.GetKubeClientStub = nil
	if fake.getKubeClientReturnsOnCall == nil {
		fake.getKubeClientReturnsOnCall = make(map[int]struct {
			result1 v1.CoreV1Interface
			result2 error
		})
	}
	fake.getKubeClientReturnsOnCall[i] = struct {
		result1 v1.CoreV1Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetKubeConnection() (*rest.Config, error) {
	fake.getKubeConnectionMutex.Lock()
	ret, specificReturn := fake.getKubeConnectionReturnsOnCall[len(fake.getKubeConnectionArgsForCall)]
	fake.getKubeConnectionArgsForCall = append(fake.getKubeConnectionArgsForCall, struct {
	}{})
	fake.recordInvocation("GetKubeConnection", []interface{}{})
	fake.getKubeConnectionMutex.Unlock()
	if fake.GetKubeConnectionStub != nil {
		return fake.GetKubeConnectionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getKubeConnectionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetKubeConnectionCallCount() int {
	fake.getKubeConnectionMutex.RLock()
	defer fake.getKubeConnectionMutex.RUnlock()
	return len(fake.getKubeConnectionArgsForCall)
}

func (fake *FakeManager) GetKubeConnectionCalls(stub func() (*rest.Config, error)) {
	fake.getKubeConnectionMutex.Lock()
	defer fake.getKubeConnectionMutex.Unlock()
	fake.GetKubeConnectionStub = stub
}

func (fake *FakeManager) GetKubeConnectionReturns(result1 *rest.Config, result2 error) {
	fake.getKubeConnectionMutex.Lock()
	defer fake.getKubeConnectionMutex.Unlock()
	fake.GetKubeConnectionStub = nil
	fake.getKubeConnectionReturns = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetKubeConnectionReturnsOnCall(i int, result1 *rest.Config, result2 error) {
	fake.getKubeConnectionMutex.Lock()
	defer fake.getKubeConnectionMutex.Unlock()
	fake.GetKubeConnectionStub = nil
	if fake.getKubeConnectionReturnsOnCall == nil {
		fake.getKubeConnectionReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
			result2 error
		})
	}
	fake.getKubeConnectionReturnsOnCall[i] = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetLogger() *zap.SugaredLogger {
	fake.getLoggerMutex.Lock()
	ret, specificReturn := fake.getLoggerReturnsOnCall[len(fake.getLoggerArgsForCall)]
	fake.getLoggerArgsForCall = append(fake.getLoggerArgsForCall, struct {
	}{})
	fake.recordInvocation("GetLogger", []interface{}{})
	fake.getLoggerMutex.Unlock()
	if fake.GetLoggerStub != nil {
		return fake.GetLoggerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getLoggerReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetLoggerCallCount() int {
	fake.getLoggerMutex.RLock()
	defer fake.getLoggerMutex.RUnlock()
	return len(fake.getLoggerArgsForCall)
}

func (fake *FakeManager) GetLoggerCalls(stub func() *zap.SugaredLogger) {
	fake.getLoggerMutex.Lock()
	defer fake.getLoggerMutex.Unlock()
	fake.GetLoggerStub = stub
}

func (fake *FakeManager) GetLoggerReturns(result1 *zap.SugaredLogger) {
	fake.getLoggerMutex.Lock()
	defer fake.getLoggerMutex.Unlock()
	fake.GetLoggerStub = nil
	fake.getLoggerReturns = struct {
		result1 *zap.SugaredLogger
	}{result1}
}

func (fake *FakeManager) GetLoggerReturnsOnCall(i int, result1 *zap.SugaredLogger) {
	fake.getLoggerMutex.Lock()
	defer fake.getLoggerMutex.Unlock()
	fake.GetLoggerStub = nil
	if fake.getLoggerReturnsOnCall == nil {
		fake.getLoggerReturnsOnCall = make(map[int]struct {
			result1 *zap.SugaredLogger
		})
	}
	fake.getLoggerReturnsOnCall[i] = struct {
		result1 *zap.SugaredLogger
	}{result1}
}

func (fake *FakeManager) GetManagerOptions() extension.ManagerOptions {
	fake.getManagerOptionsMutex.Lock()
	ret, specificReturn := fake.getManagerOptionsReturnsOnCall[len(fake.getManagerOptionsArgsForCall)]
	fake.getManagerOptionsArgsForCall = append(fake.getManagerOptionsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetManagerOptions", []interface{}{})
	fake.getManagerOptionsMutex.Unlock()
	if fake.GetManagerOptionsStub != nil {
		return fake.GetManagerOptionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getManagerOptionsReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetManagerOptionsCallCount() int {
	fake.getManagerOptionsMutex.RLock()
	defer fake.getManagerOptionsMutex.RUnlock()
	return len(fake.getManagerOptionsArgsForCall)
}

func (fake *FakeManager) GetManagerOptionsCalls(stub func() extension.ManagerOptions) {
	fake.getManagerOptionsMutex.Lock()
	defer fake.getManagerOptionsMutex.Unlock()
	fake.GetManagerOptionsStub = stub
}

func (fake *FakeManager) GetManagerOptionsReturns(result1 extension.ManagerOptions) {
	fake.getManagerOptionsMutex.Lock()
	defer fake.getManagerOptionsMutex.Unlock()
	fake.GetManagerOptionsStub = nil
	fake.getManagerOptionsReturns = struct {
		result1 extension.ManagerOptions
	}{result1}
}

func (fake *FakeManager) GetManagerOptionsReturnsOnCall(i int, result1 extension.ManagerOptions) {
	fake.getManagerOptionsMutex.Lock()
	defer fake.getManagerOptionsMutex.Unlock()
	fake.GetManagerOptionsStub = nil
	if fake.getManagerOptionsReturnsOnCall == nil {
		fake.getManagerOptionsReturnsOnCall = make(map[int]struct {
			result1 extension.ManagerOptions
		})
	}
	fake.getManagerOptionsReturnsOnCall[i] = struct {
		result1 extension.ManagerOptions
	}{result1}
}

func (fake *FakeManager) ListExtensions() []extension.Extension {
	fake.listExtensionsMutex.Lock()
	ret, specificReturn := fake.listExtensionsReturnsOnCall[len(fake.listExtensionsArgsForCall)]
	fake.listExtensionsArgsForCall = append(fake.listExtensionsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListExtensions", []interface{}{})
	fake.listExtensionsMutex.Unlock()
	if fake.ListExtensionsStub != nil {
		return fake.ListExtensionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listExtensionsReturns
	return fakeReturns.result1
}

func (fake *FakeManager) ListExtensionsCallCount() int {
	fake.listExtensionsMutex.RLock()
	defer fake.listExtensionsMutex.RUnlock()
	return len(fake.listExtensionsArgsForCall)
}

func (fake *FakeManager) ListExtensionsCalls(stub func() []extension.Extension) {
	fake.listExtensionsMutex.Lock()
	defer fake.listExtensionsMutex.Unlock()
	fake.ListExtensionsStub = stub
}

func (fake *FakeManager) ListExtensionsReturns(result1 []extension.Extension) {
	fake.listExtensionsMutex.Lock()
	defer fake.listExtensionsMutex.Unlock()
	fake.ListExtensionsStub = nil
	fake.listExtensionsReturns = struct {
		result1 []extension.Extension
	}{result1}
}

func (fake *FakeManager) ListExtensionsReturnsOnCall(i int, result1 []extension.Extension) {
	fake.listExtensionsMutex.Lock()
	defer fake.listExtensionsMutex.Unlock()
	fake.ListExtensionsStub = nil
	if fake.listExtensionsReturnsOnCall == nil {
		fake.listExtensionsReturnsOnCall = make(map[int]struct {
			result1 []extension.Extension
		})
	}
	fake.listExtensionsReturnsOnCall[i] = struct {
		result1 []extension.Extension
	}{result1}
}

func (fake *FakeManager) PatchFromPod(arg1 admission.Request, arg2 *v1a.Pod) admission.Response {
	fake.patchFromPodMutex.Lock()
	ret, specificReturn := fake.patchFromPodReturnsOnCall[len(fake.patchFromPodArgsForCall)]
	fake.patchFromPodArgsForCall = append(fake.patchFromPodArgsForCall, struct {
		arg1 admission.Request
		arg2 *v1a.Pod
	}{arg1, arg2})
	fake.recordInvocation("PatchFromPod", []interface{}{arg1, arg2})
	fake.patchFromPodMutex.Unlock()
	if fake.PatchFromPodStub != nil {
		return fake.PatchFromPodStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.patchFromPodReturns
	return fakeReturns.result1
}

func (fake *FakeManager) PatchFromPodCallCount() int {
	fake.patchFromPodMutex.RLock()
	defer fake.patchFromPodMutex.RUnlock()
	return len(fake.patchFromPodArgsForCall)
}

func (fake *FakeManager) PatchFromPodCalls(stub func(admission.Request, *v1a.Pod) admission.Response) {
	fake.patchFromPodMutex.Lock()
	defer fake.patchFromPodMutex.Unlock()
	fake.PatchFromPodStub = stub
}

func (fake *FakeManager) PatchFromPodArgsForCall(i int) (admission.Request, *v1a.Pod) {
	fake.patchFromPodMutex.RLock()
	defer fake.patchFromPodMutex.RUnlock()
	argsForCall := fake.patchFromPodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) PatchFromPodReturns(result1 admission.Response) {
	fake.patchFromPodMutex.Lock()
	defer fake.patchFromPodMutex.Unlock()
	fake.PatchFromPodStub = nil
	fake.patchFromPodReturns = struct {
		result1 admission.Response
	}{result1}
}

func (fake *FakeManager) PatchFromPodReturnsOnCall(i int, result1 admission.Response) {
	fake.patchFromPodMutex.Lock()
	defer fake.patchFromPodMutex.Unlock()
	fake.PatchFromPodStub = nil
	if fake.patchFromPodReturnsOnCall == nil {
		fake.patchFromPodReturnsOnCall = make(map[int]struct {
			result1 admission.Response
		})
	}
	fake.patchFromPodReturnsOnCall[i] = struct {
		result1 admission.Response
	}{result1}
}

func (fake *FakeManager) RegisterExtensions() error {
	fake.registerExtensionsMutex.Lock()
	ret, specificReturn := fake.registerExtensionsReturnsOnCall[len(fake.registerExtensionsArgsForCall)]
	fake.registerExtensionsArgsForCall = append(fake.registerExtensionsArgsForCall, struct {
	}{})
	fake.recordInvocation("RegisterExtensions", []interface{}{})
	fake.registerExtensionsMutex.Unlock()
	if fake.RegisterExtensionsStub != nil {
		return fake.RegisterExtensionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.registerExtensionsReturns
	return fakeReturns.result1
}

func (fake *FakeManager) RegisterExtensionsCallCount() int {
	fake.registerExtensionsMutex.RLock()
	defer fake.registerExtensionsMutex.RUnlock()
	return len(fake.registerExtensionsArgsForCall)
}

func (fake *FakeManager) RegisterExtensionsCalls(stub func() error) {
	fake.registerExtensionsMutex.Lock()
	defer fake.registerExtensionsMutex.Unlock()
	fake.RegisterExtensionsStub = stub
}

func (fake *FakeManager) RegisterExtensionsReturns(result1 error) {
	fake.registerExtensionsMutex.Lock()
	defer fake.registerExtensionsMutex.Unlock()
	fake.RegisterExtensionsStub = nil
	fake.registerExtensionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RegisterExtensionsReturnsOnCall(i int, result1 error) {
	fake.registerExtensionsMutex.Lock()
	defer fake.registerExtensionsMutex.Unlock()
	fake.RegisterExtensionsStub = nil
	if fake.registerExtensionsReturnsOnCall == nil {
		fake.registerExtensionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerExtensionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetManagerOptions(arg1 extension.ManagerOptions) {
	fake.setManagerOptionsMutex.Lock()
	fake.setManagerOptionsArgsForCall = append(fake.setManagerOptionsArgsForCall, struct {
		arg1 extension.ManagerOptions
	}{arg1})
	fake.recordInvocation("SetManagerOptions", []interface{}{arg1})
	fake.setManagerOptionsMutex.Unlock()
	if fake.SetManagerOptionsStub != nil {
		fake.SetManagerOptionsStub(arg1)
	}
}

func (fake *FakeManager) SetManagerOptionsCallCount() int {
	fake.setManagerOptionsMutex.RLock()
	defer fake.setManagerOptionsMutex.RUnlock()
	return len(fake.setManagerOptionsArgsForCall)
}

func (fake *FakeManager) SetManagerOptionsCalls(stub func(extension.ManagerOptions)) {
	fake.setManagerOptionsMutex.Lock()
	defer fake.setManagerOptionsMutex.Unlock()
	fake.SetManagerOptionsStub = stub
}

func (fake *FakeManager) SetManagerOptionsArgsForCall(i int) extension.ManagerOptions {
	fake.setManagerOptionsMutex.RLock()
	defer fake.setManagerOptionsMutex.RUnlock()
	argsForCall := fake.setManagerOptionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1
}

func (fake *FakeManager) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeManager) StartCalls(stub func() error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeManager) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Stop() {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
	}{})
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		fake.StopStub()
	}
}

func (fake *FakeManager) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeManager) StopCalls(stub func()) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeManager) Watch() error {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
	}{})
	fake.recordInvocation("Watch", []interface{}{})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.watchReturns
	return fakeReturns.result1
}

func (fake *FakeManager) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeManager) WatchCalls(stub func() error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *FakeManager) WatchReturns(result1 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) WatchReturnsOnCall(i int, result1 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addExtensionMutex.RLock()
	defer fake.addExtensionMutex.RUnlock()
	fake.addWatcherMutex.RLock()
	defer fake.addWatcherMutex.RUnlock()
	fake.getKubeClientMutex.RLock()
	defer fake.getKubeClientMutex.RUnlock()
	fake.getKubeConnectionMutex.RLock()
	defer fake.getKubeConnectionMutex.RUnlock()
	fake.getLoggerMutex.RLock()
	defer fake.getLoggerMutex.RUnlock()
	fake.getManagerOptionsMutex.RLock()
	defer fake.getManagerOptionsMutex.RUnlock()
	fake.listExtensionsMutex.RLock()
	defer fake.listExtensionsMutex.RUnlock()
	fake.patchFromPodMutex.RLock()
	defer fake.patchFromPodMutex.RUnlock()
	fake.registerExtensionsMutex.RLock()
	defer fake.registerExtensionsMutex.RUnlock()
	fake.setManagerOptionsMutex.RLock()
	defer fake.setManagerOptionsMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ extension.Manager = new(FakeManager)
